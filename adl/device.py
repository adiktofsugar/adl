import sqlite3
import os
import hashlib
import base64
import logging
import requests

from lxml import etree

from xml_tools import ADEPT_NS, NSMAP, add_subelement, sign_xml
from api_call import Activate
import account
import utils

db_file = 'adl.db'

class Device():
  def __init__(self):
    self.name = None
    self.device_key = None
    self.device_id = None
    self.fingerprint = None
    self.type = 'standalone'

  def generate_key(self):
    # Not exactly sure how it is really generated in ADE
    # However as it changes each time, I am guessing it is ok to generate it randomly
    self.device_key = base64.b64encode(os.urandom(16))

  def generate_fingerprint(self):
    # Not sure this is portable
    # Also not the same way it is generated by ADE. Is it an issue ?
    with open('/etc/machine-id', 'r') as f:
      h = hashlib.sha1()
      h.update(f.read())
      d = h.digest()
      self.fingerprint = base64.b64encode(d)

  def __str__(self):
    return "{}: {} ({})".format(self.name, self.type, self.fingerprint)

##### List devices
def device_list(args, data):
  print("Known devices:")
  a = data.get_current_account()
  if a is not None:
    for d in a.devices:
      print("-  {} {} - {} ".format(d.name, d.device_id, d.type))
  else:
    print "No registered device"


###### Register devices
# TODO: dry mode
def device_register(args, data):
  print("Looking for ADEPT support on {}".format(args.mountpoint))
  d = read_device_file(args.mountpoint)
  if d is None:
    logging.error("This device does not seem to support ADEPT DRM")
    return

  current_account = data.get_current_account()
  if current_account is None:
    logging.error("Please log in with a user and select it first")

  # Check it is not already in our db
  devices = current_account.devices
  for device in devices:
    if device.fingerprint == d.fingerprint:
      print("Device already exists in the DB")
      return

  # Check if it is not already activated
  username, plk, device_id = read_activation_file(args.mountpoint)

  if username is not None and plk is not None:
    # Already activated
    a = data.find_account_by_sign(username)
    if a is not None:
      if a.get_private_key() == plk:
        # Activated by a known user
        logging.info("Device is already activated for user {} but is not known by adl, registering it".format(username))
        d.device_id = device_id
        data.add_device(a.urn, d)
        return

    logging.error("Device is already activated for an unknown user. Doing nothing or all books on the device will become unreadable")
    return 

  # Activate device
  logging.info("Activating device ...")
  activation_token = activate(current_account, d)
  if activation_token is None:
    logging.error("Activation failed")
    return

  # Store file in the device
  activation_file_content = build_activation_file(current_account, activation_token, data.config)
  logging.debug(activation_file_content)

  if write_activation_file(args.mountpoint, activation_file_content):
    # Store info in db
    data.add_device(current_account.urn, d)
    print("Activation successful")
  else:
    print("Error while writing activation file")

  return

def activate(acc, d):
  act = Activate(acc, d)
  return act.call(False) # TODO dry mode

def read_device_file(mountpoint):
  try:
    with open("{}/.adobe-digital-editions/device.xml".format(mountpoint), "r") as device_file:
      d = Device()
      tree_root = etree.fromstring(device_file.read())
      d.name = tree_root.find("{http://ns.adobe.com/adept}deviceName").text
      d.type = tree_root.find("{http://ns.adobe.com/adept}deviceType").text
      d.fingerprint = tree_root.find("{http://ns.adobe.com/adept}fingerprint").text

      print("Found device: {}".format(d))
      return d

  except Exception:
    print("Could not find device. Maybe it doesn't support ADEPT DRM ?")
    return None

def read_activation_file(mountpoint):
  try:
    with open("{}/.adobe-digital-editions/activation.xml".format(mountpoint), "r") as activation_file:
      tree_root = etree.fromstring(activation_file.read())
      creds = tree_root.find("{http://ns.adobe.com/adept}credentials")
      username = creds.find("{http://ns.adobe.com/adept}username").text
      plk = creds.find("{http://ns.adobe.com/adept}privateLicenseKey").text

      at = tree_root.find("{http://ns.adobe.com/adept}activationToken")
      device_id = at.find("{http://ns.adobe.com/adept}device").text

      logging.info("This device is already activated for user {}".format(username))
      return username, plk, device_id
  except Exception:
    logging.info("Activation data not found")

  return None, None, None

def write_activation_file(mountpoint, content):
  try:
    with open("{}/.adobe-digital-editions/activation.xml".format(mountpoint), "w") as activation_file:
      activation_file.write(content)
  except Exception:
    logging.exception("Error while updating device !")
    return False

  return True

def build_activation_file(acc, reply, config):
  xml = etree.Element("{%s}activationInfo" % ADEPT_NS, nsmap=NSMAP)

  service = etree.Element("{%s}activationServiceInfo" % ADEPT_NS, nsmap=NSMAP)
  xml.append(service)
  add_subelement(service, "authURL", config.auth_url)
  add_subelement(service, "userInfoURL", config.userinfo_url)
  add_subelement(service, "activationURL", config.auth_url)
  add_subelement(service, "certificate", config.activation_certificate)

  cred = etree.Element("{%s}credentials" % ADEPT_NS, nsmap=NSMAP)
  xml.append(cred)
  add_subelement(cred, "user", acc.urn)
  add_subelement(cred, "licenseCertificate", acc.licenseCertificate)
  add_subelement(cred, "privateLicenseKey", acc.get_private_key())
  add_subelement(cred, "authenticationCertificate", config.authentication_certificate)
  user = etree.Element("username", attrib = {"method": acc.sign_method})
  user.text = acc.sign_id
  cred.append(user)

  activationToken = etree.fromstring(reply)
  xml.append(activationToken)

  return etree.tostring(xml)
  
